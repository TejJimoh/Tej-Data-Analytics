------------------------------------- DEVELOPED BY TEJ FOR NWF LTD---------------------------------------

/***
A TUPLE  is a combination of members from one or multiple dimensions; a tuple can only contain ONE member from each hierachy. 
A tuple that contains a member from a single dimension is synonymous to a member. For example, ([time].[January 8th, 2009]) would be 
 a tuple even though it refers to only one dimension. 
A tuple that refers to multiple dimensions could be ([product].[Cadillac], [time].[January 8th, 2009]). If you attempt to reference more 
than one member from each dimension the tuple will become invalid; for example ([product].[Cadillac], [time].[January], [time].[February]) 
would be incorrect. 
As a rule tuples are enclosed in parenthesis; if a tuple is comprised of a single member then parenthesis aren't necessary; but, 
for the sake of consistency you should always use parenthesis when referring to a tuple.

SETS 
A set constitutes collection of zero, one or more tuples with the same dimensionality and explicitly enclosed in the set { } symbol.

***/

---Error 1: Members, tuples or sets must use the same hierarchies in the  function.

---Solution 1: make sure Tuples have same hierachy
---solution 2: Enclose members in ( )
----Try crosjoin solution 1 and 2. What happens?

--- Figure 1 : As long as you use more than one hierachy, you must enclosed in ().
SELECT 
{
[Received Date].[Financial Calendar].[Financial Year] 
,[Received Date].[Calendar Year].[Calendar Year]
} 
 ON rows, 
 {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]

/*** Solution 1: We now have single SET with SAME Hierachy dimensionality. Note that this works without () . In fact if you put the 
bracket (), the select statement will fail because you will now have a single turple with 2 members belonging to the same hierachy. 
Remember,a tuple can only contain ONE member from each hierachy. The SET is actually treating the members as 2 different Turples.
You can prove this by enclosing individual members in ().***/
SELECT  { 
[Received Date].[Financial Calendar].[Financial Year],
[Received Date].[Financial Calendar].[Financial Period]
}
  ON rows, 
 {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]


---Solution  2: A single Turple inside a SET. A tuple can only contain ONE member from each hierachy
SELECT {
([Received Date].[Financial Calendar].[Financial Year],
 [Received Date].[Calendar Year].[Calendar Year])
}  ON rows, 
 {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]

---Solution 3: Turn this to a single turple without a SET

SELECT 

([Received Date].[Financial Calendar].[Financial Year] 
,[Received Date].[Calendar Year].[Calendar Year])

 ON rows, 
 {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]

---BRAIN TEASER : Now try Solution 1 and Solution 2 with Crossjoin function. 
--Note that Solution 2 will work while Soluion 1 fails. WHY ? 



/*** The EMPTY candidates of MDX namely Non Empty, NonEmpty and Not isEmpty(Value_Expression) ***/
--this is the initial query without **Empty**
WITH
SET TheCurrentDate As StrToMember("[Received Date].[Calendar].[Date].&["+Format(now(), "yyyy-MM-ddT00:00:00")+"]")
MEMBER MEASURES.QuantityInquarantine AS 
CASE WHEN [Measures].[Qty In QC] = 0 THEN NULL
ELSE [Measures].[Qty In QC]
END
MEMBER MEASURES.AcceptedQuantity AS 
CASE WHEN [Measures].[Accepted Qty] < 200000 THEN NULL
ELSE [Measures].[Accepted Qty]
END
select {LastPeriods(40,TheCurrentDate.item(0))}
on rows, {MEASURES.QuantityInquarantine,[Measures].[AcceptedQuantity]} on columns
from [Goods Received]


--- NonEmpty(SET,[SET]) function: This simply returns SET that are not empty from the second SET
---See Select 1, Select 2 and Select 3. Select 3 is basically useless without the second parameter set. 
--ie you get the same result as the original query above.
WITH
SET TheCurrentDate As StrToMember("[Received Date].[Calendar].[Date].&["+Format(now(), "yyyy-MM-ddT00:00:00")+"]")
MEMBER MEASURES.QuantityInquarantine AS 
CASE WHEN [Measures].[Qty In QC] = 0 THEN NULL
ELSE [Measures].[Qty In QC]
END
MEMBER MEASURES.AcceptedQuantity AS 
CASE WHEN [Measures].[Accepted Qty] < 200000 THEN NULL
ELSE [Measures].[Accepted Qty]
END

---Select 1
select NONEMPTY({LastPeriods(40,TheCurrentDate.item(0))},{MEASURES.QuantityInquarantine})
---select {LastPeriods(400,TheCurrentDate.item(0))}

--Select 2
--select NONEMPTY({LastPeriods(40,TheCurrentDate.item(0))},MEASURES.AcceptedQuantity)
---Select 3
--select NONEMPTY({LastPeriods(10,TheCurrentDate.item(0))})
on rows, {MEASURES.QuantityInquarantine,[Measures].[AcceptedQuantity]} on columns
from [Goods Received]


--- Non Empty. This is not a function but keyword that is prefixed before the SETS defining the axis and is basically used to remove NULLS.
---It will basically remeove the row(s) OR column(s) where ALL the entries are NULL
WITH
SET TheCurrentDate As StrToMember("[Received Date].[Calendar].[Date].&["+Format(now(), "yyyy-MM-ddT00:00:00")+"]")
MEMBER MEASURES.QuantityInquarantine AS 
CASE WHEN [Measures].[Qty In QC] = 0 THEN NULL
ELSE [Measures].[Qty In QC]
END
MEMBER MEASURES.AcceptedQuantity AS 
CASE WHEN [Measures].[Accepted Qty] < 200000 THEN NULL
ELSE [Measures].[Accepted Qty]
END

---Select 1
select NON EMPTY {LastPeriods(40,TheCurrentDate.item(0))}
on rows, {MEASURES.QuantityInquarantine,[Measures].[AcceptedQuantity]} on columns
from [Goods Received]


/***  NOT IsEmpty(Expression). When you combine this with Filter function, you have a flexible and powerful way of eliminating NULL. 
***/




/**********************************   TIME FUNCTIONS EXAMPLES    *****************************************/


---- 1) ClosingPeriod(Level,Member) and OpeningPeriod(Level,Member)  

---- Hard coding. Give me the cost and quantity of Goods bought in the last quarter of 2014
select ClosingPeriod(
					[Received Date].[Calendar].[Calendar Quarter]
					,[Received Date].[Calendar].[Calendar Year].&[2014]
					)
 on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]


/*** Important Note

•If a level expression is specified, the ClosingPeriod function uses the dimension that contains the specified level and returns the last sibling among the descendants of the default member at the specified level. 

•If both a level expression and a member expression are specified, the ClosingPeriod function returns the last sibling among the descendants of specified member at the specified level. 

•If neither a level expression nor a member expression is specified, the ClosingPeriod function uses the default level and member of the dimension (if any) in the cube with a type of Time.


----The ClosingPeriod function is equivalent to the following MDX statement. Note that SELF is default when flag is not specify for Descendants and 1 is the dafault for Tail Count.
SELECT Tail(
Descendants([Received Date].[Calendar].[Calendar Year].&[2014], [Received Date].[Calendar].[Calendar Quarter]),1)
 on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]

***/


---- Hard coding. Give me the cost and quantity of Goods bought in the first month of Quater 4 of  2014
select OpeningPeriod([Received Date].[Calendar].[Calendar Month]
, [Received Date].[Calendar].[Calendar Quarter].&[2014]&[4]
)
 on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]

---What happen if you use diff hierachy???





----The OpeningPeriod function is equivalent to the following MDX statement. Note that SELF is default when flag is not specify for Descendants and 1 is the dafault for Head Count.
select Head(
Descendants( [Received Date].[Calendar].[Calendar Quarter].&[2014]&[4],[Received Date].[Calendar].[Calendar Month]))
 on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]



/***
Dynamically getting 2 years ago. Give me the cost and quantity of Goods bought in the last Quarter of 2 years ago.

Note the use of DECLARED SET namely CurrentYEAR. Without using .ITEM(0) with CurrentYear, you get an error 
saying (The CLOSINGPERIOD function expects a member expression for the 2 argument. A tuple set expression was used.)
ITEM(0) is what actually make CurrentYEAR to act as member. Note that ClosingPeriod(Level,Member) expect the second 
argument to be a member. Same principle applies to OpeningPeriod
Note that the Level and the member are on the same hierachy.

.Item(index) usage

1) For example, 2nd argument in ClosingPeriod function requires a member but TwoYearsAgo being passed as 2nd argument is SET.
TwoYearsAgo.Item(0) will return a member. Note that since we are returning one member, we have to pass in item(0)

2) LastPeriods(4,[Received Date].[Calendar].[Calendar Quarter].&[2014]&[4]) will give us the 4 quarters in 2014 while
   LastPeriods(4,[Received Date].[Calendar].[Calendar Quarter].&[2014]&[4]).item(1) will give us the 2nd quarter in 2014

3) {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]}.item(0) will return only [Measures].[Total Accepted Cost GBP].
This is an example of returning a turple from a SET.



***/

WITH
SET CurrentYEAR As StrToMember("[Received Date].[Calendar].[Calendar Year].&["+Format(now(), "yyyy")+"]")
SET TwoYearsAgo as CurrentYEAR.Item(0).Lag(2)
select ClosingPeriod([Received Date].[Calendar].[Calendar Quarter],TwoYearsAgo.ITEM(0))
---LastPeriods(4,[Received Date].[Calendar].[Calendar Quarter].&[2014]&[4]).item(0)
 on columns, 
 {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} 
 --- {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]}.item(0)
 on rows
from [Goods Received]



-- 2) Lastperiods(Index,member expression)
----Returns a set of members up to and including a specified member.

--- Hard coding current year. Give me Accepted Cost and Accepted Quantity bought in the last 5 years 

select 
Lastperiods(5,[Received Date].[Calendar].[Calendar Year].&[2015])
 on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]

---Give me Accepted Cost bought in year 2014. Note extensive usage of .item(index)
select 
---Member.item. Returning 4th member from members
Lastperiods(5,[Received Date].[Calendar].[Calendar Year].&[2015]) .item(3)
 on rows, 
 ---SET.Item . Returning Turple from Set.
 {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]}.item(0) on columns
from [Goods Received]

---Give me the cost of daily goods bought in the last one year including today's date (Method 1)
WITH
SET TheCurrentDate As StrToMember("[Received Date].[Calendar].[Date].&["+Format(now(), "yyyy-MM-ddT00:00:00")+"]")
select {LastPeriods(366,TheCurrentDate.item(0))}
on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]


---Give me the cost of daily goods bought in the last one year including today's date (Method 2)
WITH
SET TheCurrentDate As StrToMember("[Received Date].[Calendar].[Date].&["+Format(now(), "yyyy-MM-ddT00:00:00")+"]")
select {LastPeriods(-366,ParallelPeriod([Received Date].[Calendar].[Calendar Year],1,TheCurrentDate.item(0)))}
on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]

--- Dynamically getting current year. Give me the cost of goods bought in the last 5 years 
WITH
SET CurrentYEAR As StrToMember("[Received Date].[Calendar].[Calendar Year].&["+Format(now(), "yyyy")+"]")
select LastPeriods(5,CurrentYEAR.item(0))
 on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]


----This is the same as
WITH
SET CurrentYEAR As StrToMember("[Received Date].[Calendar].[Calendar Year].&["+Format(now(), "yyyy")+"]")
select CurrentYEAR.item(0) :  CurrentYEAR.item(0).lag(4)
 on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]

------BRAIN TEASER : GIVE ME THE LAST 5 QUARTERS STARTING WITH THE FIRST QUARTER OF THE CURRENT YEAR.
WITH
SET CurrentYEAR As StrToMember("[Received Date].[Calendar].[Calendar Year].&["+Format(now(), "yyyy")+"]")
select LastPeriods(5,openingPeriod([Received Date].[Calendar].[Calendar Quarter],CurrentYEAR.item(0)))
on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]


--- 3) ParallelPeriod(Level,Index,Member) ---- Level >= Member

---Cousin( Member_Expression , Ancestor_Member_Expression )

---Dynamically getting current month.The select statement below will look at the current month and go back one year.
WITH
SET CurrentMonth As StrToMember("[Received Date].[Calendar].[Calendar Month].&["+Format(now(), "yyyy")+"]&["+Format(now(), "MM")+"]")
select {CurrentMonth.item(0),ParallelPeriod([Received Date].[Calendar].[Calendar Year],1,CurrentMonth.item(0))}
on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]

--- Same as below
WITH
SET CurrentMonth As StrToMember("[Received Date].[Calendar].[Calendar Month].&["+Format(now(), "yyyy")+"]&["+Format(now(), "MM")+"]")
select  {CurrentMonth.item(0),cousin(CurrentMonth.item(0),Ancestor(CurrentMonth.item(0),[Received Date].[Calendar].[Calendar Year]).lag(1))}
on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]


---Dynamically getting current month.The select statement below will look at the current month and go back two Quarters.
WITH
SET CurrentMonth As StrToMember("[Received Date].[Calendar].[Calendar Month].&["+Format(now(), "yyyy")+"]&["+Format(now(), "MM")+"]")
select {CurrentMonth.item(0),ParallelPeriod([Received Date].[Calendar].[Calendar Quarter],2,CurrentMonth.item(0))}
on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]




---4) PeriodsToDate(Level,member)
--Dynamicalling selecting all the months in the current Quarter
WITH
SET CurrentMonth As StrToMember("[Received Date].[Calendar].[Calendar Month].&["+Format(now(), "yyyy")+"]&["+Format(now(), "MM")+"]")
select PeriodsToDate([Received Date].[Calendar].[Calendar Quarter],
CurrentMonth.item(0))


on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]


--Dynamicalling selecting all the days in the current Quarter Method 1 (Using PeriodsToDate)
WITH
SET TheCurrentDate As StrToMember("[Received Date].[Calendar].[Date].&["+Format(now(), "yyyy-MM-ddT00:00:00")+"]")
select PeriodsToDate([Received Date].[Calendar].[Calendar Quarter],TheCurrentDate.item(0))
on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]

--Dynamicalling selecting all the days in the current Quarter Method 2 (Using QTD)
WITH
SET TheCurrentDate As StrToMember("[Received Date].[Calendar].[Date].&["+Format(now(), "yyyy-MM-ddT00:00:00")+"]")
select QTD(TheCurrentDate.item(0))
on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]


--Dynamicalling selecting all the days in the current month 
WITH
SET TheCurrentDate As StrToMember("[Received Date].[Calendar].[Date].&["+Format(now(), "yyyy-MM-ddT00:00:00")+"]")
select	MTD(TheCurrentDate.item(0))
on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]

--Dynamicalling selecting all the days in the current year 
WITH
SET TheCurrentDate As StrToMember("[Received Date].[Calendar].[Date].&["+Format(now(), "yyyy-MM-ddT00:00:00")+"]")
select	YTD(TheCurrentDate.item(0))
on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]




--Good example of YTD demo
/*** The Aggregate function calculates the value based on the aggregation type specified in the cube for the measure. In our case, the 
[Measures].[Total Accepted Cost GBP] aggregation type is Sum, so the Aggregate function could be exchanged for the Sum function.
This is the reason to use the Aggregate keyword so that whatever is specified in the cube will be used.
***/
WITH
Member measures.TotalAcceptedCostYTD as
sum(YTD([Received Date].[Calendar].currentmember),[Measures].[Total Accepted Cost GBP])
Member measures.AcceptedQuantityYTD as
aggregate(YTD([Received Date].[Calendar].currentmember),[Measures].[Accepted Qty])
select non empty([Received Date].[Calendar].[Calendar QUARTER].members) on rows,
{[Measures].[Total Accepted Cost GBP], measures.TotalAcceptedCostYTD,[Measures].[Accepted Qty], measures.AcceptedQuantityYTD} on columns
from [Goods Received]


/**** VERY IMPORTANT *****/

---PLEASE NOTE THAT WHEN YOU SET YOUT ATTRIBUTE TYPE TO FINANCIALYEARS, FINANCIALMONTHS, FINANCIALWEEKS ETC, you cannot use the short version of PeriodsToDate ie YTD, QTD, 
---MTD ETC.  You have to use the actual long version of PeriodsTodDate(level,member)For example, figure 1 below will fail while figure 2 will execute successfully


---Figure 1 : Does this error actually make sense?
WITH

select	YTD([Received Date].[Financial Calendar].&[2015]&[8]&[30]   )
on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]

---Figure 2
WITH
select	PeriodsToDate
(
[Received Date].[Financial Calendar].[Financial Year],[Received Date].[Financial Calendar].[Financial Week].&[2015]&[8]&[30]  )
on rows, {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]} on columns
from [Goods Received]


--- 2) SET FUNCTIONS EXAMPLES (When you think of set, think of .members)

--BOTTOMCOUNT -- TOPCOUNT --BOTTOMPERCENT --TOPPERCENT --BOTTOMSUM -- TOPSUM --- TAIL --- HEAD

--BOTTOMCOUNT(Set,Count,[Numeric measures] )
--Sort a SET in ascending order. This soring is what differnciate it from similar function called TAIL
--Give me the bottom 10(least) product sold in the lifetime of NWF LTD.

--Figure 1 explain the basic syntax. The expected parameters are, Set,Count and Numeric Measure. 
---In most cases BottomCount will require the use of filter to eliminate NULLS as seen in Figre 2

---FIGURE 1
SELECT 
      {[Measures].[Net Invoice Sales Current]} ON COLUMNS,
      
      BOTTOMCOUNT(
	
					{[Product].[Part Code With Description].[Part Code With Description].MEMBERS},  10, [Measures].[Net Invoice Sales Current]
	             )         
       ON ROWS 
from [NWFBI]

--FIGURE 2 (NOTE THE USE OF FILTER WITH NOT ISEMPTY). Although the third [Numeric Expression] parameter is optional, you might get 
--unpredictable resulset if you leave it out as in 
---the example below when used with other functions like FILTER and ISEMPTY. However, when BottomCount is used alone without other 
---functions (very unlikely) and you leave out [numeric Expression parameter,
---the function will return specified members in natural order in the table. That is, it will act like TAIL function.
SELECT 
      {[Measures].[Net Invoice Sales Current]} ON COLUMNS,
      
      BOTTOMCOUNT(
	  FILTER(
     {[Product].[Part Code With Description].[Part Code With Description].MEMBERS}, NOT ISEMPTY([Measures].[Net Invoice Sales Current])
AND [Measures].[Net Invoice Sales Current] > 0 ), 10, [Measures].[Net Invoice Sales Current]
        )         
       ON ROWS 
from [NWFBI]

---- TEJ TIP: The beauty of BottomCount and topCount function is that they break the hierachy by eliminating ALL member from the resultset. 
--How do we prove this?
----Figure A and B are similar except the inclusion of BottomCount in Figure B. Figure B will exclude ALL member by breaking the hierachy 
--while Figure A will include All memeber.
--- FIGURE A
SELECT 
      {[Measures].[Net Invoice Sales Current]} ON COLUMNS,
      
     
	  FILTER(
     {[Product].[Part Code With Description].MEMBERS}, NOT ISEMPTY([Measures].[Net Invoice Sales Current])
AND [Measures].[Net Invoice Sales Current] > 0 )
            
       ON ROWS 
from [NWFBI]

---FIGURE B
SELECT 
      {[Measures].[Net Invoice Sales Current]} ON COLUMNS,
      
      BOTTOMCOUNT(
	  FILTER(
     {[Product].[Part Code With Description].MEMBERS}, NOT ISEMPTY([Measures].[Net Invoice Sales Current])
AND [Measures].[Net Invoice Sales Current] > 0 ), 10, [Measures].[Net Invoice Sales Current]
        )         
       ON ROWS 
from [NWFBI]


---Tail(Set_Expression [ ,Count ] ) 
---In it's purest form
SELECT 
      {[Measures].[Net Invoice Sales Current]} ON COLUMNS,
      
      TAIL(
	         {[Product].[Part Code With Description].[Part Code With Description].MEMBERS},10
          )         
       ON ROWS 
from [NWFBI]


---This is the same as BOTTOMCOUNT above. Note that data ordering and hierachy breaking is naturally done in 
---BottomCount but you have to include these 2 with TAIL 
--- if you want it to act like Bottocount.
SELECT 
      {[Measures].[Net Invoice Sales Current]} ON COLUMNS,
      
      TAIL(
	       ORDER(
                FILTER( {[Product].[Part Code With Description].[Part Code With Description].MEMBERS}, 
				NOT ISEMPTY([Measures].[Net Invoice Sales Current])
AND [Measures].[Net Invoice Sales Current] > 0 )
, [Measures].[Net Invoice Sales Current],BDESC),10
  )         
       ON ROWS 
from [NWFBI]



/*** NOTE
The IsEmpty function is the only way to reliably test for an empty cell because the empty cell VALUE has special meaning 
---in Microsoft SQL Server Analysis Services.
I personnaly use combination of Filter with NOT IsEmpty() function.
***/
WITH MEMBER MEASURES.ISITEMPTY AS 
 ISEMPTY([Measures].[Net Invoice Sales Current])

SELECT 
      {[Measures].[Net Invoice Sales Current],MEASURES.ISITEMPTY} ON COLUMNS,
      
       [Sales Customer].[Sales Customer Name].[Sales Customer Name] ON ROWS 
from [NWFBI]




----TopCount(Set_Expression,Count [ ,Numeric_Expression ] )

--Give me the top 10(most) product sold in the lifetime of NWF LTD.
---TOPCOUNT : Sorts a set in descending order and returns the specified number of elements with the highest values. the keyword is SORT.
SELECT 
      {[Measures].[Net Invoice Sales Current]} ON COLUMNS,
      
      TOPCOUNT(
     {[Product].[Part Code With Description].[Part Code With Description].MEMBERS}, 10, [Measures].[Net Invoice Sales Current]
        )         
       ON ROWS 
from [NWFBI]


---Head(Set_Expression [ ,Count ] )  
---Head in its simplest form
SELECT 
      {[Measures].[Net Invoice Sales Current]} ON COLUMNS,
      
      HEAD(
         {[Product].[Part Code With Description].[Part Code With Description].MEMBERS},10
          )   
		      
       ON ROWS 
from [NWFBI]

---To get HEAD to behave like Topcount, Order by BDESC.

SELECT 
      {[Measures].[Net Invoice Sales Current]} ON COLUMNS,
      
      HEAD(
          ORDER(  {[Product].[Part Code With Description].[Part Code With Description].MEMBERS},[Measures].[Net Invoice Sales Current], BDESC),10
        )   
		      
       ON ROWS 
from [NWFBI]

---NOTE : If a numeric expression is not specified, the function returns the set of members in natural order,
--without any sorting, behaving like the Head (MDX) function.
--- For example, the 2 select statements below will give you exactly the same result. 


---- to get Topcount to behave like HEAD, take out the optional Numerical_Expression.
SELECT 
      {[Measures].[Net Invoice Sales Current]} ON COLUMNS,
      
      TOPCOUNT(
     {[Product].[Part Code With Description].[Part Code With Description].MEMBERS}, 10
        )         
       ON ROWS 
from [NWFBI]


SELECT 
      {[Measures].[Net Invoice Sales Current]} ON COLUMNS,
      
      HEAD(
     {[Product].[Part Code With Description].[Part Code With Description].MEMBERS}, 10
        )         
       ON ROWS 
from [NWFBI]



--- With Crossjoin
---Crossjoin(Set_Expression1 ,Set_Expression2 [,...n] ) 
SELECT 
      {[Measures].[Net Invoice Sales Current]} ON COLUMNS,
  
	  TOPCOUNT(

     crossjoin({[Sales Customer].[Sales Customer Name].[Sales Customer Name].members},
	 {[Product].[Part Code With Description].[Part Code With Description].MEMBERS}), 10, [Measures].[Net Invoice Sales Current]
        ) 
		       
       ON ROWS 
from [NWFBI]



--BOTTOMPERCENT(Set,Percentage,Numeric Measure )
--Give me the bottom 10 (least) percent Vendor that we purchased from based on Accepted Cost
--This returns mainly null values
SELECT 
     {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]}  ON COLUMNS,
      
      BOTTOMPERCENT(
     {[Vendor].[Vendor Name].[Vendor Name].members}, 10, [Measures].[Total Accepted Cost GBP]
     			   )         
       ON ROWS 
FROM [Goods Received]

--This eliminates null values. Note the usage of "Not IsEmpty" with the filter function

SELECT 
     {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]}  ON COLUMNS,
      
      BOTTOMPERCENT(filter(
     {[Vendor].[Vendor Name].[Vendor Name].members}, NOT IsEmpty([Measures].[Total Accepted Cost GBP]) and [Measures].[Total Accepted Cost GBP] > 0
	 ) ,10, [Measures].[Total Accepted Cost GBP]
     			   )         
       ON ROWS 
FROM [Goods Received]


--TOPPERCENT( Set, Percentage,Numeric Measure )
---Sorts a set in descending order, and returns a set of tuples with the highest values whose cumulative total is equal to or 
---greater than a specified percentage.
--Give me the top 20 (most) percent Vendor that we purchased from  based on Accepted Cost

SELECT 
     {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]}  ON COLUMNS,
      
      TOPPERCENT(
     {[Vendor].[Vendor Name].[Vendor Name].members},20, [Measures].[Total Accepted Cost GBP]
     			   )         
       ON ROWS 
FROM [Goods Received]

----IMPORTANT: Please note that TopPercent or BottomPercent is just the closest estimate to the specified percentage.
--Let's use the MDX below to prove this concept.
--note the use of format_string
WITH MEMBER [measures].[PercentPurchaseInvoicePerVendorPerYear] as
  ([Measures].[Total Accepted Cost GBP]) / 
  ([Vendor].[Vendor Name].currentmember.parent,[Measures].[Total Accepted Cost GBP])
 ,format_string = '0.00%'

 SELECT 
     {[Measures].[Total Accepted Cost GBP],[measures].[PercentPurchaseInvoicePerVendorPerYear],[Measures].[Accepted Qty]}  ON COLUMNS,
      
      TOPPERCENT(
     {[Vendor].[Vendor Name].[Vendor Name].members}, 20, [Measures].[Total Accepted Cost GBP]
     			   )         
       ON ROWS 
FROM [Goods Received]


--BOTTOMSUM( Set, Value,Numeric Expression» )
-- Give me a set of Vendors with the lowest values whose cumulative Accepted Cost total is more than or equal to 900.
--This returns mainly null values
SELECT 
     {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]}  ON COLUMNS,
      
      BOTTOMSUM(
     {[Vendor].[Vendor Name].[Vendor Name].members}, 900, [Measures].[Total Accepted Cost GBP]
     			   )         
       ON ROWS 
FROM [Goods Received]

--This eliminates null values. Note the usage of "Not IsEmpty" with the filter function

SELECT 
     {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]}  ON COLUMNS,
      
      BOTTOMSUM(FILTER(
     {[Vendor].[Vendor Name].[Vendor Name].members},NOT IsEmpty([Measures].[Total Accepted Cost GBP]) and [Measures].[Total Accepted Cost GBP] > 0), 900, [Measures].[Total Accepted Cost GBP]
     			   )         
       ON ROWS 
FROM [Goods Received]


--TOPSUM( Set, Value,Numeric Expression» )
-- Give me a set of Vendors with the highest values whose cumulative Accepted Cost total is more than or equal to 50000.
---Look at the result. what do you think is wrong here?
---Well, try 10,000,000 and 100,000,000. Note that 
---Green Produce France EUR	[£31,544,685.41]and Multi Packaging Solutions Litt	[£27,560,173.00] are not in the resultset when 
--you use 10,000,000 despite there value 
--greater than 10,000,000. It simply show the vendor with the highest cumulative value in this case Blue Arrow.
---it's impotant to know the limitation of these functions!	
SELECT 
     {[Measures].[Total Accepted Cost GBP],[Measures].[Accepted Qty]}  ON COLUMNS,
      
      TOPSUM(
     {[Vendor].[Vendor Name].[Vendor Name].members}, 100000000, [Measures].[Total Accepted Cost GBP]
     			   )         
       ON ROWS 
FROM [Goods Received]




---MDX uses the Generate() function and named sets to support iteration.
---Generate(Set_Expression1 ,Set_Expression2 [ , ALL ]  )
----Generate function returns a set generated by applying the tuples in the second set to each tuple in the first set. 
---Simply put, the resultset of the second 
---- SET is displayed while the first SET is mainly for iteration.


-- There are currently 17 memebers in the calendar year, hence the iteration is 17 times. 
---Removing 'ALL' means distinct records will be returned.
---Open calendar member for confirmation

---With ALL
SELECT 
GENERATE( 
{[Received Date].[Calendar].[Calendar Year].members},
 {[Measures].[Total Accepted Cost GBP]}, ALL
)
ON COLUMNS
FROM [Goods Received]


GO
---without ALL
SELECT 
GENERATE( 
{[Received Date].[Calendar].[Calendar Year].members},
 {[Measures].[Total Accepted Cost GBP]}
)
ON COLUMNS
FROM [Goods Received]

GO
----Testing to see datasets in row
SELECT [Received Date].[Calendar].[Calendar Year].members ON ROWS,
GENERATE( 
{[Received Date].[Calendar].[Calendar Year].members},
 {[Measures].[Total Accepted Cost GBP]},ALL
)
ON COLUMNS
FROM [Goods Received]

---Hierachy.currentmember returns 1 record, hence just one iteration.
SELECT 
GENERATE( 
{[Received Date].[Calendar].Currentmember},
 {[Measures].[Total Accepted Cost GBP]}, ALL
)
ON COLUMNS
FROM [Goods Received]

GO

SELECT  [Received Date].[Calendar].Currentmember ON ROWS,
GENERATE( 
{[Received Date].[Calendar].Currentmember},
 {[Measures].[Total Accepted Cost GBP]}, ALL
)
ON COLUMNS
FROM [Goods Received]


---There are 4 members in Agreement Status, hence 4 iterations.
SELECT 
GENERATE( 
{[Purchase Agreement].[Agreement Status].[Agreement Status]},
 {[Measures].[Total Accepted Cost GBP]}, ALL
)
ON COLUMNS
FROM [Goods Received]

---- Same MDX statement as above without 'ALL'. This eliminate duplicates hence just one record returns
SELECT 
GENERATE( 
{[Purchase Agreement].[Agreement Status].[Agreement Status]},
 {[Measures].[Total Accepted Cost GBP]}
)
ON COLUMNS
FROM [Goods Received]

---Further analysis: Please note that 2017 and 2018 are displayed because they are members of the first and the second set
---In a nutshell, generate looks at the members that exist in both sets to display. It's like union of the sets

SELECT [Measures].[Total Accepted Cost GBP] ON ROWS,
GENERATE( 
{[Received Date].[Calendar].[Calendar Year].members},
 {[Received Date].[Calendar].[Calendar Year].&[2017],[Received Date].[Calendar].[Calendar Year].&[2018],[Received Date].[Calendar].[Calendar Year].&[2033]}
)
ON COLUMNS
FROM [Goods Received]



---Real live use is normally with crossjoin and  or topcount
---BRAINSTORM : Combination of Filter and NOT IsEmpty
----GIVE ME THE TOP FIRST 3 PURCHASE PER VENDOR PER YEAR
--MDX 1 : note the proper usage of {} for SET_EXPRESSION.
---What is wrong with the resultset?
WITH MEMBER [MEASURES].NonEmptyAcceptedCost AS 
CoalesceEmpty([Measures].[Total Accepted Cost GBP],0)

SELECT  {[Measures].[Total Accepted Cost GBP]} on columns,
filter(

		{	GENERATE
			( 
				{ [Received Date].[Calendar].[Calendar Year].MEMBERS },
					{	crossjoin
						(	{
						       [Received Date].[Calendar].[Calendar Year].MEMBERS
							 } ,
								
							 {	topcount(
										  {
												[Vendor].[Vendor Group].[Vendor Group].MEMBERS
										   }	,3,[Measures].[Total Accepted Cost GBP]
										 )
							 }
						)
					}
			)
			
		 }	, not isempty([Measures].[Total Accepted Cost GBP])
		   
		)

ON rows
FROM [Goods Received]

---similar to MDX 1 above but using nonempty. What is wrong with the resultset
----GIVE ME THE FIRST 3 PURCHASE PER VENDOR PER YEAR
----MDX 2
SELECT  {[Measures].[Total Accepted Cost GBP]} on columns,
nonempty(

	GENERATE
			( 
				{[Received Date].[Calendar].[Calendar Year].MEMBERS},
		{
		crossjoin
				(	
					{[Received Date].[Calendar].[Calendar Year].MEMBERS},
			topcount(
						[Vendor].[Vendor Group].[Vendor Group].MEMBERS,3,[Measures].[Total Accepted Cost GBP]
					)
				)
		}
			)
			,[Measures].[Total Accepted Cost GBP]
		)
ON rows
FROM [Goods Received]

----What you need to remeber is ISEmpty expects Value_Expression as a parameter not SET. For example, run the two MDX queries below:

--- Figure 1 returns right result because a VALUE_EXPRESSION was passed to ISEMPTY function
WITH MEMBER MEASURES.ISITEMPTY AS 
 ISEMPTY([Measures].[Net Invoice Sales Current])

SELECT 
      {[Measures].[Net Invoice Sales Current],MEASURES.ISITEMPTY} ON COLUMNS,
      
       [Sales Customer].[Sales Customer Name].[Sales Customer Name] ON ROWS 
from [NWFBI]

--- Figure 2 returns the wrong result because a SET_EXPRESSION was passed to ISEMPTY function
WITH MEMBER MEASURES.ISITEMPTY AS 
 ISEMPTY({[Measures].[Net Invoice Sales Current]})

SELECT 
      {[Measures].[Net Invoice Sales Current],MEASURES.ISITEMPTY} ON COLUMNS,
      
       [Sales Customer].[Sales Customer Name].[Sales Customer Name] ON ROWS 
from [NWFBI]



--- Now let's fully analysed the results of MDX 1 and MDX 2. Can you see anything wrong in these results? Yes, because we only suppose to get 
--- 3 set of rows for each year. To solve this problem, always remember to make sure that the second SET in Generate function is the CURRENTMEMBER
--- of the hierachy. 
---- One of the valid and acceptable MDX is :


SELECT  {[Measures].[Total Accepted Cost GBP]} on columns,
filter(

		{	GENERATE
			( 
				{[Received Date].[Calendar].[Calendar Year].MEMBERS},
					{	crossjoin
						(	{
						       
						       [Received Date].[Calendar].currentmember
							 } ,
								
							 {	topcount(
										  {
												[Vendor].[Vendor Group].[Vendor Group].MEMBERS
										   }	,3,[Measures].[Total Accepted Cost GBP]
										 )
							 }
						)
					}
			)
			
		 }	, not isempty([Measures].[Total Accepted Cost GBP])
		)

ON rows
FROM [Goods Received]







---- BRAIN TEASER -- A TASTE OF THE POWER OF MDX
--- Let's make things very interesting by calculating the percentage of "Purchase Invoice Cost GBP" per Vendor per year for the top 5 vendors.
---Note the usage of .currentmember and .currentmember.parent.
with member [measures].[PercentPurchaseInvoicePerVendorPerYear] as
  ([Measures].[Purchase Invoice Cost GBP]) / 
  ([Vendor].[Vendor Name].currentmember.parent,[Measures].[Purchase Invoice Cost GBP])
 ,format_string = '0.00%'


SELECT {[Measures].[Purchase Invoice Cost GBP],[measures].[PercentPurchaseInvoicePerVendorPerYear]}
on columns,
filter(GENERATE
( 
{[Invoice Date].[Calendar].[Calendar Year].MEMBERS},
crossjoin
  ({[Invoice Date].[Calendar].currentmember} ,
topcount(
		[Vendor].[Vendor Name].[Vendor Name].MEMBERS,5,[Measures].[Purchase Invoice Cost GBP]
        ) 
  )
), not isempty([Measures].[Purchase Invoice Cost GBP]))
ON rows
from [Purchase Invoices]



---Using topcount with crossjoin is not good enough. As can be seen in the query below.However, using Generate loops through
---each year and pick the top 5 Vendors with with highest purchase invoice. Compare MDX A with MDX B below

---MDX A 
SELECT {[Measures].[Purchase Invoice Cost GBP]}
on columns,
filter(GENERATE
( 
{[Invoice Date].[Calendar].[Calendar Year].MEMBERS},
crossjoin
  ({[Invoice Date].[Calendar].currentmember} ,
topcount(
		[Vendor].[Vendor Name].[Vendor Name].MEMBERS,5,[Measures].[Purchase Invoice Cost GBP]
        ) 
  )
), not isempty([Measures].[Purchase Invoice Cost GBP]))
ON rows
from [Purchase Invoices]

GO
---MDX B
---Simply crossjoining Calendar Years and the set of top 5 Vendors will display the top 5 Vendors for all time, 
---repeated for each year, as shown in the following example:
SELECT {[Measures].[Purchase Invoice Cost GBP]}
on columns,
filter(
crossjoin
  ({[Invoice Date].[Calendar].[Calendar Year].MEMBERS},
topcount(
		[Vendor].[Vendor Name].[Vendor Name].MEMBERS,5,[Measures].[Purchase Invoice Cost GBP]
        ) 
  
), not isempty([Measures].[Purchase Invoice Cost GBP]))
ON rows
from [Purchase Invoices]

--- Conversation with BI team
--- Heather : Tej, I found the YTD for calendar year below quite useful, but I need the same information for Financial year.

WITH

Member measures.TotalAcceptedCostYTD as
sum(YTD([Received Date].[Calendar].currentmember),[Measures].[Total Accepted Cost GBP])
Member measures.AcceptedQuantityYTD as
aggregate(YTD([Received Date].[Calendar].currentmember),[Measures].[Accepted Qty])
select non empty([Received Date].[Calendar].[Calendar Quarter].members) on rows,
{[Measures].[Total Accepted Cost GBP], measures.TotalAcceptedCostYTD,[Measures].[Accepted Qty], measures.AcceptedQuantityYTD} on columns
from [Goods Received]

-----SET TheCurrentDate As StrToMember("[Received Date].[Calendar].[Date].&["+Format(now(), "yyyy-MM-ddT00:00:00")+"]")



--- SOLUTION: Note the use of Periodstodate with .currentmember in the second argument
WITH
Member measures.TotalAcceptedCostYTD as
sum(PeriodsToDate([Received Date].[Financial Calendar].[Financial Year],[Received Date].[Financial Calendar].currentmember),[Measures].[Total Accepted Cost GBP])
Member measures.AcceptedQuantityYTD as
sum(PeriodsToDate([Received Date].[Financial Calendar].[Financial Year],[Received Date].[Financial Calendar].currentmember),[Measures].[Measures].[Accepted Qty])
select non empty([Received Date].[Financial Calendar].[Financial Period].members) on rows,
{[Measures].[Total Accepted Cost GBP], measures.TotalAcceptedCostYTD,[Measures].[Accepted Qty], measures.AcceptedQuantityYTD} on columns
from [Goods Received]

--Except(Set_Expression1, Set_Expression2 [, ALL ] )
--Evaluates two sets and removes those tuples in the first set that also exist in the second set, 
--optionally retaining duplicates.
-- Give me all Customer Category except 'Not Defined' 

SELECT 
      {[Measures].[Invoice Value]} ON COLUMNS,
       Except(
				{[Customer].[Customer Category].[Customer Category].MEMBERS},
				{([Customer].[Customer Category].[Customer Category].&[Not Defined])
				}
      	
			) ON ROWS 
from [NWFBI]


---- Another way of writing this is to use (-) as seen below. Additionally, get rid of the 2 unknown

SELECT 
      {[Measures].[Invoice Value]} ON COLUMNS,
      
				{[Customer].[Customer Category].[Customer Category].MEMBERS} -
				{([Customer].[Customer Category].[Customer Category].&[Not Defined])} - {([Customer].[Customer Category].[Customer Category].&[Unknown])}
      	     - {([Customer].[Customer Category].[All].UNKNOWNMEMBER)}
		 ON ROWS 
from [NWFBI]



--- You've just been told to calculate the percentage of "Purchase Invoice Cost GBP" per Vendor per year for the top 5 
--vendors. You've also been instructed to exclude any
----Purchase Invoice issued to 'Danston Ltd' despite the fact that this is one of our top 5 Vendors. 
--Note that the 6th topmost Vendor was simply added to the resulset.

---give the demo below without Except and then with the inclusion of Except.

with member [measures].[PercentPurchaseInvoicePerVendorPerYear] as
  ([Vendor].[Vendor Name].currentmember,[Measures].[Purchase Invoice Cost GBP]) / 
  ([Vendor].[Vendor Name].currentmember.parent,[Measures].[Purchase Invoice Cost GBP])
 ,format_string = '0.00%'


SELECT {[Measures].[Purchase Invoice Cost GBP],[measures].[PercentPurchaseInvoicePerVendorPerYear]}
on columns,
filter(GENERATE
( 
{[Invoice Date].[Calendar].[Calendar Year].MEMBERS},
crossjoin
  ({[Invoice Date].[Calendar].currentmember} ,
topcount(
		---[Vendor].[Vendor Name].[Vendor Name].MEMBERS,6,[Measures].[Purchase Invoice Cost GBP]
		EXCEPT([Vendor].[Vendor Name].[Vendor Name].MEMBERS,[Vendor].[Vendor Name].[Vendor Name].&[Danston Ltd])
		,5,[Measures].[Purchase Invoice Cost GBP]
        ) 
  )
), not isempty([Measures].[Purchase Invoice Cost GBP]))
ON rows
from [Purchase Invoices]



--Exists( Set_Expression1 , Set_Expression2 [, MeasureGroupName] )

--Returns the set of tuples of the first set specified that exist with one or more tuples of the second set specified 
--If the optional <Measure Group Name> is provided, the function returns tuples that exist with one or
-- more tuples from the second set and those tuples that have associated rows in the fact table 
--of the specified measure group. 

---NOTE THAT EXISTS IS ALMOST THE OPPOSITE OF EXCEPT.
-- Give me all Vendor Group that exist for 'Not Defined' and 'Other' 

-- Give me all Invoice Value for Customer Category that exist for 'Not Defined' 

SELECT 
      {[Measures].[Invoice Value]} ON COLUMNS,
       Exists(
				{[Customer].[Customer Category].[Customer Category].MEMBERS},
				{([Customer].[Customer Category].[Customer Category].&[Not Defined])
				}
      	
			) ON ROWS 
from [NWFBI]

-- Give me all Invoice Value for Customer Category that exist for 'Not Defined' AND Unknown

SELECT 
      {[Measures].[Invoice Value]} ON COLUMNS,
       Exists(
				{[Customer].[Customer Category].[Customer Category].MEMBERS},
				{([Customer].[Customer Category].[Customer Category].&[Not Defined]),([Customer].[Customer Category].[Customer Category].&[Unknown])
				}---,"Sales Invoices"
      	
			) ON ROWS 
from [NWFBI]


---Now run the same query as above but with the third parameter of Measure Group Name specify.
-- Give me all Invoice Value for Customer Category that exist for 'Not Defined' AND Unknown
---Note that the third parameter ensure that only those tuples that have associated rows 
---in the fact table are returned. Unknown is excluded in the resultset because there is no associated row in the fact table

SELECT 
      {[Measures].[Invoice Value]} ON COLUMNS,
       Exists(
				{[Customer].[Customer Category].[Customer Category].MEMBERS},
				{([Customer].[Customer Category].[Customer Category].&[Not Defined]),([Customer].[Customer Category].[Customer Category].&[Unknown])
				},"Sales Invoices"
      	
			) ON ROWS 
from [NWFBI]




----- START FROM HERE
---Extract(Set_Expression, Hierarchy_Expression1 [,Hierarchy_Expression2, ...n] )
---The Extract function performs the opposite action of the Crossjoin function. In fact , Extract undo Crossjoin.

---MDX 1 trial Query without Extract
---Give me all the invoices to tesco for all the available calendar year
SELECT 
      {[Measures].[Invoice Value]} ON COLUMNS,
		NON EMPTY  crossjoin(Exists(
				{[Customer].[Customer Name].[Customer Name].MEMBERS},
				{([Customer].[Customer Name].[Customer Name].&[TESCO])}),[Date].[Calendar].[Calendar Year].MEMBERS)
				
      	
			ON ROWS 
from [NWFBI]

---What other simple way can you write the above?
--- let's keep life simple. This gives the same result
SELECT 
      {[Measures].[Invoice Value]} ON COLUMNS,
		NON EMPTY  crossjoin(
					{([Customer].[Customer Name].[Customer Name].&[TESCO])} ,
					{[Date].[Calendar].[Calendar Year].MEMBERS})
				
      	
			ON ROWS 
from [NWFBI]



---MDX 2, undo crossjoin by just returning Customer. Also note that Extract expect a hierachy expression as the second argument. Try
--- [Customer].[Customer Name].[Customer Name].MEMBERS instead of [Customer].[Customer Name]
SELECT 
      {[Measures].[Invoice Value]} ON COLUMNS,
	NON EMPTY	extract(  crossjoin(Exists(
				{[Customer].[Customer Name].[Customer Name].MEMBERS},
				{([Customer].[Customer Name].[Customer Name].&[Tesco])}),[Date].[Calendar].[Calendar Year].MEMBERS),
				[Customer].[Customer Name])
				
				
      	
			ON ROWS 
from [NWFBI]

---MDX 3, undo crossjoin by just returning Year
SELECT 
      {[Measures].[Invoice Value]} ON COLUMNS,
	NON EMPTY	extract(  crossjoin(Exists(
				{[Customer].[Customer Name].[Customer Name].MEMBERS},
				{([Customer].[Customer Name].[Customer Name].&[tesco])}),[Date].[Calendar].[Calendar Year].MEMBERS),
				[Date].[Calendar])
				
      	
			ON ROWS 
from [NWFBI]
--- why do we have multiple resultset in MDX 3 above and just one rowset in MDX 2?

---Descendants(Member_Expression [ , Level_Expression [ ,Desc_Flag ] ] )
---Descendants(SET_Expression [ , Level_Expression [ ,Desc_Flag ] ] )
---This will basically give us everything AFTER WEEK level(in this case Date) for current calendar year

-------MDX 1 And MDX 2 will give us the same result. 
/*** Mr Tej, what's going on ? The CurrentYEAR SET in MDX 1 is not giving us any error despite the fact 
that we are not using .ITEM(0). Can we even use CurrentYEAR.Item(0)?
***/

--- default flag is self. Leaves gives same result as self
----MDX 1
WITH 
MEMBER measures.YTDDemo AS AGGREGATE(YTD([Dim Date].[Calendar].currentmember),[Measures].[Actual Revenue])
MEMBER [Measures].[NonEmptyYTDDemo] AS COALESCEEMPTY(measures.YTDDemo,0)
MEMBER [Measures].[NonEmptyRevenue] AS COALESCEEMPTY([Measures].[Actual Revenue],0)
SET CurrentYEAR As StrToMember("[Dim Date].[Calendar].[Calendar Year].&["+Format(now(), "yyyy")+"]")
SELECT DESCENDANTS
(CurrentYEAR
, [Dim Date].[Calendar].[Calendar Week]
  , AFTER
//, SELF 
      //, BEFORE
       //,BEFORE_AND_AFTER
      //, SELF_AND_AFTER
      //, SELF_AND_BEFORE
     // ,SELF_BEFORE_AFTER
     // ,LEAVES 
) ON ROWS,
 {[Measures].[NonEmptyRevenue],[Measures].[NonEmptyYTDDemo]} ON COLUMNS
from [Sales] 

---- MDX 2 : this give same result as MDX 1
WITH 
MEMBER measures.YTDDemo AS AGGREGATE(YTD([Dim Date].[Calendar].currentmember),[Measures].[Actual Revenue])
MEMBER [Measures].[NonEmptyYTDDemo] AS COALESCEEMPTY(measures.YTDDemo,0)
MEMBER [Measures].[NonEmptyRevenue] AS COALESCEEMPTY([Measures].[Actual Revenue],0)
SET CurrentYEAR As StrToMember("[Dim Date].[Calendar].[Calendar Year].&["+Format(now(), "yyyy")+"]")
SET CalendarStartDate AS openingPeriod([Dim Date].[Calendar].[Date] , CurrentYEAR.ITEM(0))
SET CalendarEndDate AS ClosingPeriod([Dim Date].[Calendar].[Date] , CurrentYEAR.ITEM(0))
SET TheCurrentDate As StrToMember("[Dim Date].[Calendar].[Date].&["+Format(now(), "yyyyMMdd")+"]")
SET   DaysInCurrentCalendarlYear AS CalendarStartDate.ITEM(0) : CalendarEndDate.ITEM(0)
SELECT 
DaysInCurrentCalendarlYear ON ROWS,
 {[Measures].[NonEmptyRevenue],[Measures].[NonEmptyYTDDemo]} ON COLUMNS
from [Sales] 

---Descendants(Member_Expression [ , Distance [ ,Desc_Flag ] ] )
--- same as above MDX 1 and MDX 2

---MDX 3 : Note that distance is 0 based. ie counting starts from 0.
--- why do you think MDX 1 and MDX 2 might be a better option than MDX 3?
---What result do you expect if the optional distance and flag parameter is not set?
WITH 
MEMBER measures.YTDDemo AS AGGREGATE(YTD([Dim Date].[Calendar].currentmember),[Measures].[Actual Revenue])
MEMBER [Measures].[NonEmptyYTDDemo] AS COALESCEEMPTY(measures.YTDDemo,0)
MEMBER [Measures].[NonEmptyRevenue] AS COALESCEEMPTY([Measures].[Actual Revenue],0)
SET CurrentYEAR As StrToMember("[Dim Date].[Calendar].[Calendar Year].&["+Format(now(), "yyyy")+"]")
SELECT DESCENDANTS
(CurrentYEAR
,4
, SELF
) ON ROWS,
 {[Measures].[NonEmptyRevenue],[Measures].[NonEmptyYTDDemo]} ON COLUMNS
from [Sales] 


---Descendants(Member_Expression [ , Level_Expression [ ,Desc_Flag ] ] )
---This will basically give us calendar Quarters( SELF) and Calendar Year for current calendar year

----MDX 4
WITH 
MEMBER measures.YTDDemo AS AGGREGATE(YTD([Dim Date].[Calendar].currentmember),[Measures].[Actual Revenue])
MEMBER [Measures].[NonEmptyYTDDemo] AS COALESCEEMPTY(measures.YTDDemo,0)
MEMBER [Measures].[NonEmptyRevenue] AS COALESCEEMPTY([Measures].[Actual Revenue],0)
SET CurrentYEAR As StrToMember("[Dim Date].[Calendar].[Calendar Year].&["+Format(now(), "yyyy")+"]")
SELECT DESCENDANTS
(CurrentYEAR
, [Dim Date].[Calendar].[Calendar Quarter]
, SELF_AND_BEFORE
) ON ROWS,
 {[Measures].[NonEmptyRevenue],[Measures].[NonEmptyYTDDemo]} ON COLUMNS
from [Sales] 



--ORDER( «Set», «String Expression» | «Numeric Expression»[, ASC | DESC | BASC | BDESC] )
----Using Numeric Expression
WITH
MEMBER [Measures].[NonEmptyRevenue] AS COALESCEEMPTY([Measures].[Actual Revenue],0)
SELECT 
      {[Measures].[NonEmptyRevenue]} ON COLUMNS,
    
     order(
				{( [Dim Date].[Calendar].[Calendar Year].MEMBERS)}      	
			,[Measures].[NonEmptyRevenue],asc) ON ROWS 
from [Sales] 


---without ORDER

WITH
MEMBER [Measures].[NonEmptyRevenue] AS COALESCEEMPTY([Measures].[Actual Revenue],0)
SELECT 
      {[Measures].[NonEmptyRevenue]} ON COLUMNS,
    
     
				{( [Dim Date].[Calendar].[Calendar Year].MEMBERS)}      	
			 ON ROWS 
from [Sales] 


---Using String Expression. Note the use of .Currentmember.name as the string expression.

SELECT 
    {[Measures].[Actual Revenue]}  ON COLUMNS,
    
    NONEMPTY( order(
				{( [Dim Date].[Calendar].[Calendar Year].MEMBERS)}      	
			,[Dim Date].[Calendar].currentmember.name,desc),[Measures].[Actual Revenue]) ON ROWS 
from [Sales] 



----  START   START START START
/******************************************** FUN WITH NAVIGATION ( QUICK REVISION) ***********************************/


--Ancestor(Member_Expression, Level_Expression)
--Ancestor(Member_Expression, Distance)

---Ancestors: With Microsoft SQL Server Analysis Services, the set returned will always consist of a 
---single member - Analysis Services does not support multiple parents for a single member.
-- This makes Ancestor function and Ancestors function to behave the same way.

--- Please note that MDX 1 to MDX 4 will give you the same result.

--- Get me the Year Ancestor for Sep 2015

---- MDX 1 --- Ancestor(Member_Expression, Level_Expression)
SELECT 
     [Measures].[Actual Revenue] on columns,
      ANCESTOR([Dim Date].[Calendar].[Calendar Month].&[2015]&[9], 
      [Dim Date].[Calendar].[Calendar Year]) ON ROWS 
from [Sales] 

---MDX 2 ---Ancestor(Member_Expression, Distance)
---What do you get if the distance parameter is 0?
SELECT 
     [Measures].[Actual Revenue] on columns,
      ANCESTOR([Dim Date].[Calendar].[Calendar Month].&[2015]&[9], 
     2) ON ROWS 
from [Sales] 

---- MDX 3 --- Ancestors(Member_Expression, Level_Expression)
SELECT 
     [Measures].[Actual Revenue] on columns,
      ANCESTORS([Dim Date].[Calendar].[Calendar Month].&[2015]&[9], 
      [Dim Date].[Calendar].[Calendar Year]) ON ROWS 
from [Sales] 

--- MDX 4 ---Ancestors(Member_Expression, Distance)
SELECT 
     [Measures].[Actual Revenue] on columns,
      ANCESTORS([Dim Date].[Calendar].[Calendar Month].&[2015]&[9], 
     2) ON ROWS 
from [Sales] 

--- A typical use of Ancestor(s) with Descendants. The Ancentors function below returns a Member that is paseed as the first parameter to Descendants, followed by Calendar Quarter Level.
---summation of the quarters should give us the year!
SELECT 
     [Measures].[Actual Revenue] on columns,
     DESCENDANTS(
	 ANCESTORS([Dim Date].[Calendar].[Calendar Month].&[2015]&[9], 
      [Dim Date].[Calendar].[Calendar Year])
	  , [Dim Date].[Calendar].[Calendar Quarter], SELF_AND_BEFORE) 
ON ROWS 
from [Sales] 




---ascendants (member)
--- Give me all ascendants of current date.



WITH
SET TheCurrentDate As StrToMember("[Dim Date].[Calendar].[Date].&["+Format(now(), "yyyyMMdd")+"]")
SELECT 
     [Measures].[Actual Revenue] on columns,
    Ascendants(TheCurrentDate.ITEM(0)) ON ROWS 
from [Sales] 

--Children Syntax : Member.Children or Hierachy.Children
---Note that Member or Hierachy can have children but Level cannot. 

--- Member.Children : This gives you children of year 2015 ie Period1 to Period13 of 2015
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Financial Calendar].[Financial Year].&[2015].Children} ON ROWS 
from [Sales] 


---Hierachy.Children: This gives you all the years in the Financial Calendar. WHY JUST THE YEARS??? The answer lies in the content of Members.
--- ie the direct children of ALL is Year
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Financial Calendar].Children} ON ROWS 
from [Sales] 


---Note that specifying Hierachy without .Members or .Children will give you one liner ALL. This is equivalent to 
--- Hierachy.currentmember that will also give you one liner ALL. Note that ALL is the Parent of YEAR in the [Financial Calendar Hierachy]
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Financial Calendar]} ON ROWS 
from [Sales] 

SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Financial Calendar].currentmember} ON ROWS 
from [Sales] 

-- This gives you first Period of year 2015
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Financial Calendar].[Financial Year].&[2015].firstchild} ON ROWS 
from [Sales] 

--- This gives you unknown year -1
SELECT 
       [Measures].[Actual Revenue]  on columns,
     [Dim Date].[Financial Calendar].firstchild ON ROWS 
from [Sales] 

-- This gives you last Period of year 2015
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Financial Calendar].[Financial Year].&[2015].lastchild} ON ROWS 
from [Sales] 



--Since you are at Year level, this gives you ALL. It does not matter what Year member you use, you will still 
-- get ALL

SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Financial Calendar].[Financial Year].&[2015].Parent} ON ROWS 
from [Sales] 


-- The Currentmember is ALL and her children is Year. Hence, this gives you all the Years in the Hierachy
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Financial Calendar].currentmember.children} ON ROWS 
from [Sales] 

--- The currentmember ALL have no parent since it is topmost in the Hierachy hence below returns nothing
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Financial Calendar].currentmember.parent} ON ROWS 
from [Sales] 

---Look at the current year and give me a year before current year.

---Method 1
WITH
SET CurrentYEAR As StrToMember("[Dim Date].[Calendar].[Calendar Year].&["+Format(now(), "yyyy")+"]")
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {CurrentYEAR.ITEM(0).LAG(1)} ON ROWS 
from [Sales] 

---Method 2
WITH
SET CurrentYEAR As StrToMember("[Dim Date].[Calendar].[Calendar Year].&["+Format(now(), "yyyy")+"]")
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {CurrentYEAR.ITEM(0).prevmember} ON ROWS 
from [Sales] 

---Method 3
WITH
SET CurrentYEAR As StrToMember("[Dim Date].[Calendar].[Calendar Year].&["+Format(now(), "yyyy")+"]")
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {CurrentYEAR.ITEM(0).LEAD(-1)} ON ROWS 
from [Sales] 



---Look at the current year and give me a year after current year.

---Method 1
WITH
SET CurrentYEAR As StrToMember("[Dim Date].[Calendar].[Calendar Year].&["+Format(now(), "yyyy")+"]")
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {CurrentYEAR.ITEM(0).LEAD(1)} ON ROWS 
from [Sales] 

---Method 2
WITH
SET CurrentYEAR As StrToMember("[Dim Date].[Calendar].[Calendar Year].&["+Format(now(), "yyyy")+"]")
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {CurrentYEAR.ITEM(0).Nextmember} ON ROWS 
from [Sales] 

----Method 3
WITH
SET CurrentYEAR As StrToMember("[Dim Date].[Calendar].[Calendar Year].&["+Format(now(), "yyyy")+"]")
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {CurrentYEAR.ITEM(0).lag(-1)} ON ROWS 
from [Sales] 






--- Siblings is basically the Children of the same parent. First find out what the Parent is and then 
--- find out the Children. This gives you the Siblings


---The Parent of week 1 in January 2016 is January and the children of January 2016 are week 1 to week 6.
----MDX 1 and MDX 2 WILL GIVE YOU THE SAME RESULT


---MDX 1
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Calendar].[Calendar Week].&[2016]&[1]&[1].siblings}ON ROWS 
from [Sales] 

go
---MDX 2
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Calendar].[Calendar Week].&[2016]&[1]&[1].Parent.Children}ON ROWS 
from [Sales] 



---The Parent of Year 2015 is ALL. The Children of All are the years, while the last year is 2030.
----MDX 1 and MDX 2 WILL GIVE YOU THE SAME RESULT

---MDX 1
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Calendar].[Calendar Year].&[2015].Lastsibling}ON ROWS 
from [Sales] 

---MDX 2
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Calendar].[Calendar Year].&[2015].Parent.Lastchild}ON ROWS 
from [Sales] 


---The Parent of Year 2015 is ALL. The Children of All are the years, while the fist year is -1.
----MDX 1 and MDX 2 WILL GIVE YOU THE SAME RESULT

---MDX 1
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Calendar].[Calendar Year].&[2015].FirstSibling}ON ROWS 
from [Sales] 


---MDX 2
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Calendar].[Calendar Year].&[2015].Parent.firstchild}ON ROWS 
from [Sales] 









---Detail analysis of EXISTS, EXISTING and AUTO-EXISTS: Although the syntax is quite simple for all but they are responsible 
---for much of the confusion and nightmare when dealing with complex
--MDX query.


--- NATURAL BEHAVIOUR :
---When two sets are crossjoined, all possible Cartesian combinations of their members will be produced. For example, if we join two sets, 
--one with 5 members 
--and the other with 4 members,then they will produce a new set with 20 members.
--You should use Natural Behaviour anytime you want to display the values of measure(s) for the full Cartesian product of subsets of 
--DIFFERENT DIMENSIONS.


---TESTING NATURAL BEHAVIOUR
---MDX 1
----27 members
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Calendar Year].[Calendar Year].members} ON ROWS 
from [Sales] 
-- There are 27 members of Calendar year in the above MDX query


---MDX 2
--sites 5 members
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Site].[Name].[Name].members } ON ROWS 
from [Sales] 
-- There are 5 members of Site Name in the MDX 2 query above.

---MDX 3
--- If we crossed joined MDX 1 above with MDX 2 we will get 135 rows of members ie 27* 5 ( minus the header of course)
 
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Calendar Year].[Calendar Year].members} * {[Dim Site].[Name].[Name].members } ON ROWS 
from [Sales] 

--- Note that MDX 4 and MDX 5 below will give you the same result as MDX 3 above

--MDX 4
SELECT 
       [Measures].[Actual Revenue]  on columns,
     CROSSJOIN({[Dim Date].[Calendar Year].[Calendar Year].members} ,{[Dim Site].[Name].[Name].members}) ON ROWS 
from [Sales] 

---MDX 5 
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {([Dim Date].[Calendar Year].[Calendar Year].members, [Dim Site].[Name].[Name].members )} ON ROWS 
from [Sales] 


----AUTO EXIST BEHAVIOUR
---When two sets containing members of the SAME DIMENSIONS are cross-joined, the resulting set is limited to those combinations of members 
---that are actually observed in the dimension in question.
---When the WHERE clause contains an hierachy that already exist in the axis, you will get an error saying the hierachy already exist.
---However, when the Where clause contain different Hierachy to the one in the axis, records return will be limited to the Where clause.
---You should use Auto Exist when you want to display the values of measures for existing combinations of members in different levels 
---but coming from SAME HIERACHY OR DIMENSION
---Please note that you do not actually use the words Auto Exist


---TESTING AUTO EXIST BEHAVIOUR

---MDX 1
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Financial Period].[Financial Period].members} ON ROWS 
from [Sales] 
---MDX 1 above will return 339 records


---MDX 2
SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Calendar Year].[Calendar Year].members} ON ROWS 
from [Sales]
---MDX 2 above will return 27 records


---MDX 3
---If we crossed join MDX 1 above with MDX 2 above, we expect to get 27 * 339 = 9153 records.
---But instead we have 361 records. WHY?

SELECT 
       [Measures].[Actual Revenue]  on columns,
     {[Dim Date].[Calendar Year].[Calendar Year].members} * {[Dim Date].[Financial Period].[Financial Period].members} 
	
	 ON ROWS 
from [Sales]
---But instead we have 361 records. WHY?
---The reason for the behaviour is that, based on the Dim Date dimemsion, only valid Calendar year and Financial Period combinations are produced. 
---'Valid combinations' in this context means 'combinations of members that actually exist in the dimension.







---EXISTING : SYSTAX (EXISTING SET)
---Auto-exist is not applicable to CALCULATED MEMBERS and if we want to force this behaviour on them, then we need the Existing keyword.
---[Measures].[Y] looks at current context ie [Year].&[2015] while [Measures].[X] looks at the whole cube

--- Quick Analysis
WITH
MEMBER [Measures].[X] AS
      count([Dim Date].[Calendar].[Calendar Month].members)
  MEMBER [Measures].[Y] AS
      count(EXISTING [Dim Date].[Calendar].[Calendar Month].members)
SELECT
{
[Measures].[X]
,[Measures].[Y]
} ON columns
,[Dim Date].[Calendar].[Calendar Year].&[2015] ON rows
from [Sales] 



---MDX 1 without Existing
WITH
MEMBER  CountOfYears  AS
      count([Dim Date].[Calendar Year].[Calendar Year].members)

SELECT 
      { [Measures].[Actual Revenue] ,CountOfYears} on columns,
     {[Dim Date].[Calendar Year].[Calendar Year].members} * {[Dim Date].[Financial Period].[Financial Period].members } ON ROWS 
from [Sales]

/***Though we are displaying each period in the list, we still got the total count of 27 instead of the expected individual count of 1. 
THIS IS BECAUSE AUTO-EXIST DOES NOT CONTROL CALCULATED MEMBER.Please note that Auto Exist is still functional in the above MDX 1 query.
that is why we still get 361 records but Auto Exist has no control over calculated member.
By inserting the 'existing' keyword in the above query, we can produce the expected result (which is 1 per a period).
See MDX 2 below.
***/


---MDX 2
WITH
MEMBER  CountOfYears  AS
      count(EXISTING[Dim Date].[Calendar Year].[Calendar Year].members)


SELECT 
      { [Measures].[Actual Revenue] ,CountOfYears} on columns,
     {[Dim Date].[Calendar Year].[Calendar Year].members} * {[Dim Date].[Financial Period].[Financial Period].members } ON ROWS 
from [Sales]


---Let's return to EXISTS function
--Give me all customers that belong to Retail (key 5637144576)

---MDX 1
SELECT 
      { [Measures].[Actual Revenue]}  on columns,
    EXISTS( {[Dim Customers].[Name].[Name].members}, {[Dim Customers].[Cust Group ID].&[5637144576] }) ON ROWS 
from [Sales]

---Let's replicate MDX 1 above but with Auto Exist ( using same [Dim Customers] dimension )
---MDX 2
SELECT 
      { [Measures].[Actual Revenue]}  on columns,
     {([Dim Customers].[Name].[Name].members, [Dim Customers].[Cust Group ID].&[5637144576]) } ON ROWS 
from [Sales]

---When you compare MDX 1 and MDX 2 above, we can come to the conclusion that Exists and Auto Exists is almost the same thing.
---Based on the MDX 1 and MDX 2 above, it is safe to say that the main difference between Exists and Auto Exists is the fact that Exists function 
--will not 
--display the second SET. 
--Well, you are right to some extent because there are actually major differnce in the way the 2 perform their task.

---LET'S START THE DEMYSTIFICATION.


--- MDX 1 , MDX 2  and MDX 3 below will give you the same result. Please note that the WHERE clause in MDX 1 is totally 
--redundant because the second SET
--- in Exists function is already doing the function of the Where clause.
--- It is extremely important to also note that despite the existence of [Dim Customers].[Cust Group ID] in the axis and the 
--WHERE clause, no error was generated.
---MDX 1
SELECT 
      { [Measures].[Actual Revenue]}  on columns,
    EXISTS( {[Dim Customers].[Name].[Name].members}, {[Dim Customers].[Cust Group ID].&[5637144576] }) ON ROWS 
from [Sales]
WHERE [Dim Customers].[Cust Group ID].&[5637144576]

--MDX 2
SELECT 
      { [Measures].[Actual Revenue]}  on columns,
    EXISTS( {[Dim Customers].[Name].[Name].members}, {[Dim Customers].[Cust Group ID].&[5637144576] }) ON ROWS 
from [Sales]

--- MDX 3
SELECT 
      { [Measures].[Actual Revenue]}  on columns,
     {[Dim Customers].[Name].[Name].members} ON ROWS 
from [Sales]
WHERE [Dim Customers].[Cust Group ID].&[5637144576]


--- Now, lets change the query in MDX 1 so that the Where clause is now based on customer group of food (key [5637144577])
--- note that there will be no record return because the EXISTS function will execute before the WHERE clause
---MDX 4
SELECT 
      { [Measures].[Actual Revenue]}  on columns,
    EXISTS( {[Dim Customers].[Name].[Name].members}, {[Dim Customers].[Cust Group ID].&[5637144576] }) ON ROWS 
from [Sales]
WHERE [Dim Customers].[Cust Group ID].&[5637144577]

---Now, let's replace MDX 4 above with Auto-Exists
---Run this with and (without WHERE to prove that it is the same as MDX 4)
---MDX 5
SELECT 
      { [Measures].[Actual Revenue]}  on columns,
     {([Dim Customers].[Name].[Name].members, [Dim Customers].[Cust Group ID].&[5637144576]) } ON ROWS 
from [Sales]
WHERE [Dim Customers].[Cust Group ID].&[5637144577]

---unlike EXISTS, AUTO-EXISTS will generate an error with the WHERE clause as long as the hierachy in your axis also exist in the WHERE CLAUSE


---Exists function and Existing keyword can actually achieve the same result
WITH
MEMBER [Measures].[X] AS
      count(exists([Dim Date].[Calendar].[Calendar Month].members,[Dim Date].[Calendar].currentmember))
  MEMBER [Measures].[Y] AS
      count(EXISTING [Dim Date].[Calendar].[Calendar Month].members)
SELECT
  {
    [Measures].[X]
   ,[Measures].[Y]
  } ON columns,
 [Dim Date].[Calendar].[Calendar Year].members ON rows

from [Sales]





--- EXISTS WITH MEASURES
--- MDX 1 ( This will act as lookup for MDX 2 AND MDX 3 below)
SELECT 
      { [Measures].[Actual Revenue]}  on columns,
     {[Dim Customers].[Name].[Name].members} * {[Dim Customers].[Cust Group ID].&[5637144576] } ON ROWS 
from [Sales]
WHERE [Dim Date].[Calendar Year].&[2016]


-- Analysis by date
---MDX 2
WITH MEMBER  AldiAsdaActualRevenueSales AS
Aggregate( 
				{
					[Dim Customers].[Name].&[Aldi],[Dim Customers].[Name].&[Asda]
				}
					,[Measures].[Actual Revenue]
		  )
 SELECT {[Measures].[Actual Revenue],AldiAsdaActualRevenueSales} ON COLUMNS,
 ---[Dim Date].[Calendar Year].[Calendar Year].MEMBERS ON ROWS
 [Dim Date].[Calendar Year].&[2016] ON ROWS
 FROM [Sales]


-- Analysis by Customers
---MDX 3
 WITH MEMBER  AldiAsdaActualRevenueSales AS
Aggregate(
				{
					[Dim Customers].[Name].&[Aldi],[Dim Customers].[Name].&[Asda]
				}
					,[Measures].[Actual Revenue]
		  )
 SELECT {[Measures].[Actual Revenue],AldiAsdaActualRevenueSales} ON COLUMNS,
[Dim Customers].[Name].[Name].MEMBERS ON ROWS
 FROM [Sales]
WHERE [Dim Date].[Calendar Year].&[2016]

---As you can see, it displays the same summed up value against each Customes. 
---Though technically this is correct, we would ideally want to get the data only against Aldi and Asda for this new measure.

--- Deep analysis of MDX 2 and MDX 3: In MDX 2, our calculated member was based on Customer members namely Aldi and Asda. 
--The customer member was
-- not access 
--- anywhere in the row axis. the slicing was mainly done by Date. Hence, we got the right resultset. 
---In MDX 3 however, the slicing was being done by all the members in the customers. Without any function or keyword in the 
--aggregation telling
--- the calculated member to only return the current context ie Aldi and Asda member of (  [Dim Customers].[Name].[Name].MEMBERS),
-- it will base
--all it's calculation on all the members in [Dim Customers]

--- In order to force (  [Dim Customers].[Name].[Name].MEMBERS) to look at the current context ie Alda and Asda, you have to use the 
--keyword namely  EXISTING


---Let's modify MDX 3 as in MDX 4 by adding EXISTING keyword

--MDX 4 ( 

 WITH MEMBER  AldiAsdaActualRevenueSales AS
Aggregate(EXISTING
				{
					[Dim Customers].[Name].&[Aldi],[Dim Customers].[Name].&[Asda]
				}
					,[Measures].[Actual Revenue]
		  )
 SELECT {[Measures].[Actual Revenue],AldiAsdaActualRevenueSales} ON COLUMNS,

 [Dim Customers].[Name].[Name].MEMBERS ON ROWS
 FROM [Sales]
WHERE [Dim Date].[Calendar Year].&[2016]



---LET'S BRAINSTORM
/*** If you can, keep hierarchies from the same dimension together. Why? Because internally, the engine does an exists between adjacents sets in a 
--crossjoin. 
If a hierarchy from a different dimension is inserted between two hierarchies from the same dimension, this exists function happens afterwards and 
--not before. 
This can greatly expand the space and impact performance.
---this part of performance tuning is currently ongoing in our BI environment
See the example below in MDX 1
***/

---MDX 1
WITH
					SET TheCurrentDate As StrToMember("[Dim Date].[Financial Calendar].[Date].&["+Format(now(), "yyyyMMdd")+"]")
					SET DateYesterday AS TheCurrentDate.ITEM(0).LAG(1)
					SET FinancialYear As 

					ANCESTOR(
								[DateYesterday].ITEM(0)
								,[Dim Date].[Financial Calendar].[Financial Year]
							)

					SET LastFinancialYear AS FinancialYear.ITEM(0).Lag(1)
					SET FinancialYear2YrsAgo AS FinancialYear.ITEM(0).Lag(2)

					SET FInancialStartDate AS openingPeriod([Dim Date].[Financial Calendar].[Date] , FinancialYear.ITEM(0))
					SET LastFInancialStartDate AS openingPeriod([Dim Date].[Financial Calendar].[Date] , LastFinancialYear.ITEM(0))
					SET Last2YearsFInancialStartDate AS openingPeriod([Dim Date].[Financial Calendar].[Date] , FinancialYear2YrsAgo.ITEM(0))
					
					SET YesterdayDateLastYear AS 
					case when 
					ParallelPeriod([Dim Date].[Financial Calendar].[Financial Year],1,DateYesterday.item(0)) is null then
					closingPeriod([Dim Date].[Financial Calendar].[Date],LastFinancialYear.item(0))
					else ParallelPeriod([Dim Date].[Financial Calendar].[Financial Year],1,DateYesterday.item(0))
					end
					SET YesterdayDate2YearsAgo AS 
					CASE WHEN 
					ParallelPeriod([Dim Date].[Financial Calendar].[Financial Year],2,DateYesterday.item(0)) IS NULL THEN
					closingPeriod([Dim Date].[Financial Calendar].[Date],FinancialYear2YrsAgo.item(0))
					ELSE ParallelPeriod([Dim Date].[Financial Calendar].[Financial Year],2,DateYesterday.item(0)) 
					END
					


					SELECT NON EMPTY

					{[Measures].[Actual Revenue], [Measures].[Budget Revenue], [Measures].[Actual Volume],[Measures].[Budget Volume],
					[Measures].[Actual Weight],[Measures].[Budget Weight]   } ON COLUMNS,




					NON EMPTY

					{
					--[Dim Customer Group].[Cust Group Name].[Cust Group Name] *
					[Dim Customers].[Cust Group Name] *
					[Dim Customers].[Name].[Name] *

					[Dim Business].[Business Unit].[Business Unit]

					*
					---ADD SKU AND PRODUCT TO SEE MAJOR PERFORMANCE HIT

				//	[SKU].[SKU Key].[SKU Key] *
                //   [ProductSales].[Part Code].[Part Code] *
				ORDER(	periodsToDate([Dim Date].[Financial Calendar].[Financial Year],DateYesterday.item(0)) ,
				       			
				        [Dim Date].[Financial Calendar].CURRENTMEMBER.NAME,BDESC)

					}
					+
					{
					--[Dim Customer Group].[Cust Group Name].[Cust Group Name] *
					[Dim Customers].[Cust Group Name] *
					[Dim Customers].[Name].[Name] *


					[Dim Business].[Business Unit].[Business Unit]

					*
									---ADD SKU AND PRODUCT TO SEE MAJOR PERFORMANCE HIT
//					[SKU].[SKU Key].[SKU Key] *
//                    [ProductSales].[Part Code].[Part Code] *
				ORDER(	periodsToDate([Dim Date].[Financial Calendar].[Financial Year],YesterdayDateLastYear.item(0)),
					 [Dim Date].[Financial Calendar].CURRENTMEMBER.NAME,BDESC)
					}
					+
					{
					--[Dim Customer Group].[Cust Group Name].[Cust Group Name] *
					 [Dim Customers].[Cust Group Name] *
					[Dim Customers].[Name].[Name] *


					[Dim Business].[Business Unit].[Business Unit]

					*
								---ADD SKU AND PRODUCT TO SEE MAJOR PERFORMANCE HIT
//					[SKU].[SKU Key].[SKU Key] *
//                    [ProductSales].[Part Code].[Part Code] *
					order(periodsToDate([Dim Date].[Financial Calendar].[Financial Year],YesterdayDate2YearsAgo.item(0)),
					 [Dim Date].[Financial Calendar].CURRENTMEMBER.NAME,BDESC)

					}

					ON ROWS
					FROM [Sales] 






----PERIOD OVER PERIOD GROWTH
---MDX 1 shows the likely common mistake when calculating Period Over Period
---MDX 1 USING CALCULATED YEAR
WITH 

SET TheCurrentDate As StrToMember("[Dim Date].[Financial Calendar].[Date].&["+Format(now(), "yyyyMMdd")+"]")
					SET DateYesterday AS TheCurrentDate.ITEM(0).LAG(1)
					SET FinancialYear As ANCESTOR([DateYesterday].ITEM(0),[Dim Date].[Financial Calendar].[Financial Year])

Member [Measures].[Actual Revenue Growth]  As   
     (FinancialYear.item(0), [Measures].[Actual Revenue]) -
     (FinancialYear.item(0).PrevMember, [Measures].[Actual Revenue]),

FORMAT_STRING = "Currency",
VISIBLE = 1 ,    ASSOCIATED_MEASURE_GROUP = 'Fact Sales Revenue'  

SELECT 
    {[Measures].[Actual Revenue],[Measures].[Actual Revenue Growth]} on columns,
nonempty({[Dim Date].[Financial Calendar].[Financial Year].members},[Measures].[Actual Revenue])  ON rows 
from [Sales] 


---MDX 2 USING CURRENTMEMBER
---MDX 2 is a major improvement on MDX 1 but still not perfect. Why?
--- Because the first member in the set turple is wrong although this is open to debate because there is no previous year to compare the first year to.

WITH 


Member [Measures].[Actual Revenue Growth]  As   
     ([Dim Date].[Financial Calendar].CurrentMember, [Measures].[Actual Revenue]) -
    ([Dim Date].[Financial Calendar].PrevMember, [Measures].[Actual Revenue]),


FORMAT_STRING = "Currency",
VISIBLE = 1 ,    ASSOCIATED_MEASURE_GROUP = 'Fact Sales Revenue'  

SELECT 
    {[Measures].[Actual Revenue],[Measures].[Actual Revenue Growth]} on columns,
nonempty({[Dim Date].[Financial Calendar].[Financial Year].members},[Measures].[Actual Revenue])  ON rows 
from [Sales] 


---MDX 3: This eliminate the problem associated with MDX 2.
---Breakdown By year
WITH Member [Measures].[Actual Revenue Growth]

As
 ([Dim Date].[Financial Calendar].CurrentMember, [Measures].[Actual Revenue])-
 ([Dim Date].[Financial Calendar].PrevMember, [Measures].[Actual Revenue]),

FORMAT_STRING = "Currency",
VISIBLE = 1 ,    ASSOCIATED_MEASURE_GROUP = 'Fact Sales Revenue'  

SELECT 
    {[Measures].[Actual Revenue],[Measures].[Actual Revenue Growth]} on columns,
except(nonempty({[Dim Date].[Financial Calendar].[Financial Year].members},[Measures].[Actual Revenue]) ,
 nonempty ({[Dim Date].[Financial Calendar].[Financial Year].members},[Measures].[Actual Revenue]).item(0)) ON rows 
from [Sales] 


---Breakdown By Period
WITH Member [Measures].[Actual Revenue Growth]

As
 ([Dim Date].[Financial Calendar].CurrentMember, [Measures].[Actual Revenue])-
 ([Dim Date].[Financial Calendar].PrevMember, [Measures].[Actual Revenue]),

FORMAT_STRING = "Currency",
VISIBLE = 1 ,    ASSOCIATED_MEASURE_GROUP = 'Fact Sales Revenue'  

SELECT 
    {[Measures].[Actual Revenue],[Measures].[Actual Revenue Growth]} on columns,
except(nonempty({[Dim Date].[Financial Calendar].[Financial Period].members},[Measures].[Actual Revenue]) ,
 nonempty ({[Dim Date].[Financial Calendar].[Financial Period].members},[Measures].[Actual Revenue]).item(0)) ON rows 
from [Sales] 




/**** MULTIPLE CROSSJOIN PERFORMANCE WHEN USED AS DRILLDOWN *****/

WITH
					SET TheCurrentDate As StrToMember("[Dim Date].[Financial Calendar].[Date].&["+Format(now(), "yyyyMMdd")+"]")
					SET DateYesterday AS TheCurrentDate.ITEM(0).LAG(1)
					SET FinancialYear As 

					ANCESTOR(
								[DateYesterday].ITEM(0)
								,[Dim Date].[Financial Calendar].[Financial Year]
							)

					SET LastFinancialYear AS FinancialYear.ITEM(0).Lag(1)
					SET FinancialYear2YrsAgo AS FinancialYear.ITEM(0).Lag(2)

					SET FInancialStartDate AS openingPeriod([Dim Date].[Financial Calendar].[Date] , FinancialYear.ITEM(0))
					SET LastFInancialStartDate AS openingPeriod([Dim Date].[Financial Calendar].[Date] , LastFinancialYear.ITEM(0))
					SET Last2YearsFInancialStartDate AS openingPeriod([Dim Date].[Financial Calendar].[Date] , FinancialYear2YrsAgo.ITEM(0))
					
					SET YesterdayDateLastYear AS 
					case when 
					ParallelPeriod([Dim Date].[Financial Calendar].[Financial Year],1,DateYesterday.item(0)) is null then
					closingPeriod([Dim Date].[Financial Calendar].[Date],LastFinancialYear.item(0))
					else ParallelPeriod([Dim Date].[Financial Calendar].[Financial Year],1,DateYesterday.item(0))
					end
					SET YesterdayDate2YearsAgo AS 
					CASE WHEN 
					ParallelPeriod([Dim Date].[Financial Calendar].[Financial Year],2,DateYesterday.item(0)) IS NULL THEN
					closingPeriod([Dim Date].[Financial Calendar].[Date],FinancialYear2YrsAgo.item(0))
					ELSE ParallelPeriod([Dim Date].[Financial Calendar].[Financial Year],2,DateYesterday.item(0)) 
					END
					


					SELECT NON EMPTY

					{[Measures].[Actual Revenue], [Measures].[Budget Revenue], [Measures].[Actual Volume],[Measures].[Budget Volume],[Measures].[Actual Weight],[Measures].[Budget Weight]   } ON COLUMNS,




					NON EMPTY

					{
					--[Dim Customer Group].[Cust Group Name].[Cust Group Name] *
					[Dim Customers].[Cust Group Name] *
					[Dim Customers].[Name].[Name] *

					[Dim Business].[Business Unit].[Business Unit]

					*
					---ADD SKU AND PRODUCT TO SEE MAJOR PERFORMANCE HIT

				//	[SKU].[SKU Key].[SKU Key] *
                //   [ProductSales].[Part Code].[Part Code] *
				ORDER(	periodsToDate([Dim Date].[Financial Calendar].[Financial Year],DateYesterday.item(0)) ,
				       			
				        [Dim Date].[Financial Calendar].CURRENTMEMBER.NAME,BDESC)

					}
//					+
//					{
//					[Dim Customer Group].[Cust Group Name].[Cust Group Name]  *
//					[Dim Customers].[Name].[Name] *
//
//					[Dim Business].[Business Unit].[Business Unit]
//
//					*
//									---ADD SKU AND PRODUCT TO SEE MAJOR PERFORMANCE HIT
////					[SKU].[SKU Key].[SKU Key] *
////                    [ProductSales].[Part Code].[Part Code] *
//				ORDER(	periodsToDate([Dim Date].[Financial Calendar].[Financial Year],YesterdayDateLastYear.item(0)),
//					 [Dim Date].[Financial Calendar].CURRENTMEMBER.NAME,BDESC)
//					}
//					+
//					{
//					[Dim Customer Group].[Cust Group Name].[Cust Group Name]  *
//					[Dim Customers].[Name].[Name] *
//
//					[Dim Business].[Business Unit].[Business Unit]
//
//					*
//								---ADD SKU AND PRODUCT TO SEE MAJOR PERFORMANCE HIT
////					[SKU].[SKU Key].[SKU Key] *
////                    [ProductSales].[Part Code].[Part Code] *
//					order(periodsToDate([Dim Date].[Financial Calendar].[Financial Year],YesterdayDate2YearsAgo.item(0)),
//					 [Dim Date].[Financial Calendar].CURRENTMEMBER.NAME,BDESC)
//
//					}

					ON ROWS
					FROM [Sales] 


/*** 3 POSSIBLY SOLUTIONS TO MULTIPLE CROSSJOIN PERFORMANCE ISSUE IS TO USE openquery OR DRILLTHROUGH OR NON EMPTY***/

---- 1 DRILLTHROUGH

/**********WORK ON DRILLDOWN FAMILY *******************/
/*** DRILLTHROUGH as ALTERNATIVE TO MULTIPLE DRILLDOWN CROSSJOIN ***/





---Retrieves the underlying table rows that were used to create a specified cell in a cube.
DRILLTHROUGH ----maxrows 10
 SELECT [Measures].[Actual Revenue] ON COLUMNS
 FROM [Sales]
WHERE 
{
([ProductSales].[Item Key].&[157] ,
[Dim Date].[Date].&[20160424]
)
}
RETURN
[Fact Sales Revenue].[$Dim Customer Group.Cust Group Key] as [Customer Group Name],
[Fact Sales Revenue].[$Dim Customers.Customer key] as Customers,
[Fact Sales Revenue].[$Dim Business.Business key] as [Business Unit],
[Fact Sales Revenue].[$Dim Date.Date SID] as [Date],

[Fact Sales Revenue].[$SKU.SKU Key] as Skus,
[Fact Sales Revenue].[$ProductSales.item Key] as Products,
[Fact Sales Revenue].[Actual Revenue] as ActualRevenue,   
[Fact Sales Revenue].[Actual Volume] as ActualVolume,  
[Fact Sales Revenue].[Actual Weight] as ActualWeight   


/*** PROVE THIS IN TSQL ***/

SELECT 
      [Bags]
      ,[INVOICEDATE]
      ,[DateSID]
      ,[FinancialKey]
      ,[ActualRevenue]
      ,[SKU]
      ,[ItemIDDateSID]
      ,[CostByProduct]
      ,[DirectCost]
      ,[DirectMargin]
  FROM [BI_DWH_Stage].[Stage].[CustomerSales]
  where itemid = 'LIDCML0001' AND INVOICEDATE = '2016-04-24 00:00:00.000'




---2  OPENQUERY -- MDX with Stored Procedure

BEGIN

	SET NOCOUNT ON;



Truncate Table  dbo.Sales;
insert into dbo.Sales



SELECT  [[Dim Customer Group]].[Cust Group Name]].[Cust Group Name]].[MEMBER_CAPTION]]] as [Group]
      ,[[Dim Customers]].[Name]].[Name]].[MEMBER_CAPTION]]]  as Customer
      ,[[Dim Business]].[Business Unit]].[Business Unit]].[MEMBER_CAPTION]]] as BusinessUnit
      ,[[Dim Date]].[Financial Calendar]].[Financial Year]].[MEMBER_CAPTION]]] as FinacialYear
      ,[[Dim Date]].[Financial Calendar]].[Financial Period]].[MEMBER_CAPTION]]] as FinancialPeriod
      ,[[Dim Date]].[Financial Calendar]].[Financial Week]].[MEMBER_CAPTION]]] as FinancialWeek
      ,[[Dim Date]].[Financial Calendar]].[Date]].[MEMBER_CAPTION]]]  as Date
      ,Round([[Measures]].[Actual Revenue]]],2) as ActualRevenue
      ,Round([[Measures]].[Budget Revenue]]],2) as BudgetRevenue
      ,[[Measures]].[Actual Volume]]]  as ActualVolume
      ,[[Measures]].[Budget Volume]]] as BudgetVolume
      ,Round([[Measures]].[Actual Weight]]],2) as ActualWeight
      ,Round([[Measures]].[Budget Weight]]],2) as BudgetWeight
	 
  FROM 
(
select * from openquery([OLAPLINK],

'
WITH
					SET TheCurrentDate As StrToMember("[Dim Date].[Financial Calendar].[Date].&["+Format(now(), "yyyyMMdd")+"]")
					SET DateYesterday AS TheCurrentDate.ITEM(0).LAG(1)
					SET FinancialYear As 

					ANCESTOR(
								[DateYesterday].ITEM(0)
								,[Dim Date].[Financial Calendar].[Financial Year]
							)

					SET LastFinancialYear AS FinancialYear.ITEM(0).Lag(1)
					SET FinancialYear2YrsAgo AS FinancialYear.ITEM(0).Lag(2)

					SET FInancialStartDate AS openingPeriod([Dim Date].[Financial Calendar].[Date] , FinancialYear.ITEM(0))
					SET LastFInancialStartDate AS openingPeriod([Dim Date].[Financial Calendar].[Date] , LastFinancialYear.ITEM(0))
					SET Last2YearsFInancialStartDate AS openingPeriod([Dim Date].[Financial Calendar].[Date] , FinancialYear2YrsAgo.ITEM(0))
					
					SET YesterdayDateLastYear AS 
					case when 
					ParallelPeriod([Dim Date].[Financial Calendar].[Financial Year],1,DateYesterday.item(0)) is null then
					closingPeriod([Dim Date].[Financial Calendar].[Date],LastFinancialYear.item(0))
					else ParallelPeriod([Dim Date].[Financial Calendar].[Financial Year],1,DateYesterday.item(0))
					end
					SET YesterdayDate2YearsAgo AS 
					CASE WHEN 
					ParallelPeriod([Dim Date].[Financial Calendar].[Financial Year],2,DateYesterday.item(0)) IS NULL THEN
					closingPeriod([Dim Date].[Financial Calendar].[Date],FinancialYear2YrsAgo.item(0))
					ELSE ParallelPeriod([Dim Date].[Financial Calendar].[Financial Year],2,DateYesterday.item(0)) 
					END
					


					SELECT NON EMPTY

					{[Measures].[Actual Revenue], [Measures].[Budget Revenue], [Measures].[Actual Volume],[Measures].[Budget Volume],[Measures].[Actual Weight],[Measures].[Budget Weight]   } ON COLUMNS,




					NON EMPTY

					{
					[Dim Customer Group].[Cust Group Name].[Cust Group Name] *

					[Dim Customers].[Name].[Name] *

					[Dim Business].[Business Unit].[Business Unit]

					*
					
					periodsToDate([Dim Date].[Financial Calendar].[Financial Year],DateYesterday.item(0))

					}
					+
					{
					[Dim Customer Group].[Cust Group Name].[Cust Group Name]  *
					[Dim Customers].[Name].[Name] *

					[Dim Business].[Business Unit].[Business Unit]

					*
				
					periodsToDate([Dim Date].[Financial Calendar].[Financial Year],YesterdayDateLastYear.item(0))
					}
					+
					{
					[Dim Customer Group].[Cust Group Name].[Cust Group Name]  *
					[Dim Customers].[Name].[Name] *

					[Dim Business].[Business Unit].[Business Unit]

					*
			
					periodsToDate([Dim Date].[Financial Calendar].[Financial Year],YesterdayDate2YearsAgo.item(0))

					}

					ON ROWS
					FROM [Sales] 
')

)t


END













